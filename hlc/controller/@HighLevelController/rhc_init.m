function rhc_init(obj, states_measured, trims_measured)
    % RHC_INIT  Preprocessing step for RHC controller

    % create indices struct only once for efficiency
    idx = indices();

    % calculate adjacency between CAVs and HDVs and HDV reachable sets
    for iHdv = 1:obj.scenario.options.manual_control_config.amount

        % determine HDV lanelet id based on HDV's position
        state_hdv = states_measured(obj.scenario.options.amount + iHdv, :);
        lanelet_id_hdv = map_position_to_closest_lanelets( ...
            obj.scenario.lanelets, ...
            state_hdv(idx.x), ...
            state_hdv(idx.y) ...
        );

        % calculate the intersection of reachable sets with the current and
        % the successor lanelet (returned as cell array of polyshape objects
        % for each step in the prediction horizon)
        reachable_sets = obj.manual_vehicles(iHdv).compute_reachable_lane( ...
            state_hdv, ...
            lanelet_id_hdv ...
        );

        % determine empty polyshape objects
        empty_sets = cellfun(@(c) c.NumRegions == 0, reachable_sets);
        % fill empty reachable sets with a cell array containing an empty array
        obj.iter.hdv_reachable_sets(iHdv, empty_sets) = {[]};
        % convert polyshape in plain array (repeat first point to enclose the shape)
        obj.iter.hdv_reachable_sets(iHdv, ~empty_sets) = cellfun(@(c) ...
            [c.Vertices(:, 1)', c.Vertices(1, 1)'; c.Vertices(:, 2)', c.Vertices(1, 2)'], ...
            reachable_sets(~empty_sets), ...
            'UniformOutput', false ...
        );

        % update reduced coupling adjacency for cav/hdv-pairs
        for iVeh = obj.plant.indices_in_vehicle_list
            % determine CAV lanelet id based on CAV's position
            state_cav = states_measured(iVeh, :);
            % TODO isn't the lanelet_id_cav already available?
            lanelet_id_cav = map_position_to_closest_lanelets( ...
                obj.scenario.lanelets, ...
                state_cav(idx.x), ...
                state_cav(idx.y) ...
            );

            % note coupling if HDV is not behind CAV
            % if HDV is behind CAV and coupling is noted
            % the optimizer will probably not find a solution
            % since the CAV is totally in HDV's reachable set
            obj.iter.hdv_adjacency(iVeh, iHdv) = ~is_hdv_behind( ...
                lanelet_id_cav, ...
                state_cav, ...
                lanelet_id_hdv, ...
                state_hdv, ...
                obj.scenario.lanelets, ...
                obj.scenario.lanelet_relationships ...
            );
        end

    end

    % remove manual vehicle states for further calculations
    states_measured = states_measured(1:obj.scenario.options.amount, :);

    for iVeh = obj.plant.indices_in_vehicle_list
        % states of controlled vehicles can be measured directly
        obj.iter.x0(iVeh, :) = states_measured(iVeh, :);
        % get own trim
        obj.iter.trim_indices(iVeh) = trims_measured(iVeh);

        % get vehicles currently occupied areas
        obj.iter.occupied_areas{iVeh} = obj.scenario.vehicles(iVeh).get_occupied_areas( ...
            states_measured(iVeh, idx.x), ...
            states_measured(iVeh, idx.y), ...
            states_measured(iVeh, idx.heading), ...
            obj.scenario.options.offset ...
        );

        % get occupied area of emergency maneuvers for vehicle iVeh
        obj.iter.emergency_maneuvers{iVeh} = obj.mpa.get_global_emergency_maneuvers( ...
            states_measured(iVeh, idx.x), ...
            states_measured(iVeh, idx.y), ...
            states_measured(iVeh, idx.heading), ...
            trims_measured(iVeh) ...
        );

        % compute reachable sets for vehicle iVeh
        obj.iter.reachable_sets(iVeh, :) = obj.mpa.get_global_reachable_sets( ...
            states_measured(iVeh, idx.x), ...
            states_measured(iVeh, idx.y), ...
            states_measured(iVeh, idx.heading), ...
            trims_measured(iVeh) ...
        );

        % compute the reference path and speed
        [reference, v_ref] = get_reference_trajectory( ...
            obj.mpa, ...
            obj.scenario.vehicles(iVeh).reference_path, ...
            states_measured(iVeh, idx.x), ...
            states_measured(iVeh, idx.y), ...
            trims_measured(iVeh), ...
            obj.scenario.options.dt_seconds ...
        );

        % reference speed
        obj.iter.v_ref(iVeh, :) = v_ref;
        % equidistant points on the reference trajectory.
        obj.iter.reference_trajectory_points(iVeh, :, :) = reference.ReferencePoints;
        obj.iter.reference_trajectory_index(iVeh, :, :) = reference.ReferenceIndex;

        if obj.scenario.options.scenario_type ~= ScenarioType.circle

            % compute the predicted lanelets of vehicle iVeh
            predicted_lanelets = get_predicted_lanelets(obj.scenario, iVeh, reference);
            obj.iter.predicted_lanelets{iVeh} = predicted_lanelets;

            % calculate the predicted lanelet boundary of vehicle iVeh based on its predicted lanelets
            obj.iter.predicted_lanelet_boundary(iVeh, :) = get_lanelets_boundary( ...
                predicted_lanelets, ...
                obj.scenario.lanelet_boundary, ...
                obj.scenario.vehicles(iVeh).lanelets_index, ...
                obj.scenario.vehicles(iVeh).is_loop ...
            );

            % constrain the reachable sets by the boundaries of the predicted lanelets
            if obj.scenario.options.bound_reachable_sets
                obj.iter.reachable_sets(iVeh, :) = obj.mpa.get_bounded_reachable_sets( ...
                    obj.iter.reachable_sets(iVeh, :), ...
                    obj.iter.predicted_lanelet_boundary{iVeh, 3} ...
                );
            end

        end

        % force convex reachable sets if non-convex polygons are not allowed
        if ~obj.scenario.options.is_allow_non_convex
            obj.iter.reachable_sets(iVeh, :) = cellfun(@(c) convhull(c), ...
                obj.iter.reachable_sets(iVeh, :), ...
                'UniformOutput', false ...
            );
        end

        if obj.scenario.options.is_prioritized
            %% Send data to sync obj.iter for all vehicles (especially needed for priority assignment)
            obj.traffic_communication{iVeh}.send_message( ...
                obj.k, ...
                obj.iter.x0(iVeh, :), ...
                obj.iter.trim_indices(iVeh), ...
                obj.iter.predicted_lanelets{iVeh}, ...
                obj.iter.occupied_areas{iVeh}, ...
                obj.iter.reachable_sets(iVeh, :) ...
            );
        end

    end

    if obj.scenario.options.is_prioritized
        %% read messages from other vehicles (There shouldn't be any other vehicles if centralized)

        for jVeh = obj.plant.indices_in_vehicle_list
            % loop over vehicle that reads the message
            other_vehicles = setdiff(1:obj.scenario.options.amount, jVeh);

            for kVeh = other_vehicles
                % loop over vehicle from which the messages are read
                latest_msg_i = obj.traffic_communication{jVeh}.read_message( ...
                    obj.plant.all_vehicle_ids(kVeh), ...
                    obj.k, ...
                    true ...
                );

                % take state and trim of vehicle kVeh
                obj.iter.x0(kVeh, :) = [latest_msg_i.current_pose.x, latest_msg_i.current_pose.y, latest_msg_i.current_pose.heading, latest_msg_i.current_pose.speed];
                obj.iter.trim_indices(kVeh) = latest_msg_i.current_trim_index;

                % transform occupied areas
                occupied_areas = latest_msg_i.occupied_areas;
                obj.iter.occupied_areas{kVeh}.normal_offset(1, :) = occupied_areas(1).x;
                obj.iter.occupied_areas{kVeh}.normal_offset(2, :) = occupied_areas(1).y;
                obj.iter.occupied_areas{kVeh}.without_offset(1, :) = occupied_areas(2).x;
                obj.iter.occupied_areas{kVeh}.without_offset(2, :) = occupied_areas(2).y;

                % transform reachable sets to polyshape object
                obj.iter.reachable_sets(kVeh, :) = (arrayfun(@(array) {polyshape(array.x, array.y)}, latest_msg_i.reachable_sets))';

                % transform predicted lanelets
                obj.iter.predicted_lanelets{kVeh} = latest_msg_i.predicted_lanelets';

                % calculate the predicted lanelet boundary of vehicle kVeh based on its predicted lanelets
                if obj.scenario.options.scenario_type ~= ScenarioType.circle
                    obj.iter.predicted_lanelet_boundary(kVeh, :) = get_lanelets_boundary( ...
                        obj.iter.predicted_lanelets{kVeh}, ...
                        obj.scenario.lanelet_boundary, ...
                        obj.scenario.vehicles(kVeh).lanelets_index, ...
                        obj.scenario.vehicles(kVeh).is_loop ...
                    );
                end

                % get occupied areas of emergency maneuvers for vehicle kVeh
                obj.iter.emergency_maneuvers{kVeh} = obj.mpa.get_global_emergency_maneuvers( ...
                    obj.iter.x0(kVeh, idx.x), ...
                    obj.iter.x0(kVeh, idx.y), ...
                    obj.iter.x0(kVeh, idx.heading), ...
                    obj.iter.trim_indices(kVeh) ...
                );
            end

        end

    end

end
